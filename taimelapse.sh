#!/usr/bin/env bash

# Created by argbash-init v2.10.0
# ARG_OPTIONAL_SINGLE([imagemagick-options],[m],[Options for imagemagick])
### ARG_OPTIONAL_SINGLE([aspect-ratio],[],[Target aspect ratio (default is the natural aspect ratio)])
# ARG_OPTIONAL_SINGLE([cut-left],[],[Cut pixels from the left side of the image],[0])
# ARG_OPTIONAL_SINGLE([cut-right],[],[Cut pixels from the right side of the image],[0])
# ARG_OPTIONAL_SINGLE([cut-top],[],[Cut pixels from the top side of the image],[0])
# ARG_OPTIONAL_SINGLE([cut-bottom],[],[Cut pixels from the bottom side of the image],[0])
# ARG_OPTIONAL_SINGLE([cut-all],[],[Cut pixels from all sides of the image. This value is added to the side specific values.],[0])
# ARG_OPTIONAL_SINGLE([rotate],[],[Rotate the images by degrees. You also need to specify enough cut to remove the borders],[0])
# ARG_OPTIONAL_SINGLE([parallelism],[p],[How many instances of imagemagick can run simultaneously. Detects the number of CPU cores by default.],[auto])

# ARG_OPTIONAL_SINGLE([output],[o],[Output file],[timelapse.mp4])
# ARG_OPTIONAL_SINGLE([final-resolution],[],[The resolution of the final video. Aspect ratio needs to be correct],[3840x2160])
# ARG_OPTIONAL_BOOLEAN([upscale],[u],[Upscale the images with realesrgan-ncnn-vulkan])
# ARG_OPTIONAL_SINGLE([framerate],[],[Framerate of the final image in frames per second],[10])
# ARG_OPTIONAL_SINGLE([realesrgan-flags],[r],[Flags that are passed to realesrgan-ncnn-vulkan])
# ARG_OPTIONAL_SINGLE([ffmpeg-flags],[f],[Flags that are passed to ffmpeg. Used to define the encoding pipeline.],[-c:v libx264 -crf 18 -preset veryslow -pix_fmt yuv420p])
# ARG_POSITIONAL_INF([frames],[All frames in the correct order as images],[1])
# ARG_VERBOSE([])
# ARG_USE_PROGRAM([ffmpeg],[FFMPEG])
# ARG_USE_PROGRAM([convert],[IMAGEMAGICK_CONVERT])
# ARG_USE_PROGRAM([identify],[IMAGEMAGICK_IDENTIFY])
# ARG_USE_PROGRAM([realesrgan-ncnn-vulkan],[REALESRGAN_NCNN_VULKAN])
# ARG_USE_PROGRAM([mktemp],[MKTEMP])
# ARG_HELP([Create timelapse videos with AI upscaling])
# ARG_VERSION([echo $0 v0.1.0])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='mpourfhv'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_frames=('' )
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_imagemagick_options=
_arg_aspect_ratio=
_arg_cut_left="0"
_arg_cut_right="0"
_arg_cut_top="0"
_arg_cut_bottom="0"
_arg_cut_all="0"
_arg_rotate="0"
_arg_parallelism="auto"
_arg_output="timelapse.mp4"
_arg_final_resolution="3840x2160"
_arg_upscale="off"
_arg_framerate="10"
_arg_realesrgan_flags=
_arg_ffmpeg_flags="-c:v libx264 -crf 18 -preset veryslow -pix_fmt yuv420p"
_arg_verbose=0


print_help()
{
	printf '%s\n' "Create timelapse videos with AI upscaling"
	printf 'Usage: %s [-m|--imagemagick-options <arg>] [--aspect-ratio <arg>] [--cut-left <arg>] [--cut-right <arg>] [--cut-top <arg>] [--cut-bottom <arg>] [--cut-all <arg>] [--rotate <arg>] [-p|--parallelism <arg>] [-o|--output <arg>] [--final-resolution <arg>] [-u|--(no-)upscale] [--framerate <arg>] [-r|--realesrgan-flags <arg>] [-f|--ffmpeg-flags <arg>] [--verbose] [-h|--help] [-v|--version] <frames-1> [<frames-2>] ... [<frames-n>] ...\n' "$0"
	printf '\t%s\n' "<frames>: All frames in the correct order as images"
	printf '\t%s\n' "-m, --imagemagick-options: Options for imagemagick (no default)"
	printf '\t%s\n' "--aspect-ratio: Target aspect ratio (default is the natural aspect ratio) (no default)"
	printf '\t%s\n' "--cut-left: Cut pixels from the left side of the image (default: '0')"
	printf '\t%s\n' "--cut-right: Cut pixels from the right side of the image (default: '0')"
	printf '\t%s\n' "--cut-top: Cut pixels from the top side of the image (default: '0')"
	printf '\t%s\n' "--cut-bottom: Cut pixels from the bottom side of the image (default: '0')"
	printf '\t%s\n' "--cut-all: Cut pixels from all sides of the image. This value is added to the side specific values. (default: '0')"
	printf '\t%s\n' "--rotate: Rotate the images by degrees. You also need to specify enough cut to remove the borders (default: '0')"
	printf '\t%s\n' "-p, --parallelism: How many instances of imagemagick can run simultaneously. Detects the number of CPU cores by default. (default: 'auto')"
	printf '\t%s\n' "-o, --output: Output file (default: 'timelapse.mp4')"
	printf '\t%s\n' "--final-resolution: The resolution of the final video. Aspect ratio needs to be correct (default: '3840x2160')"
	printf '\t%s\n' "-u, --upscale, --no-upscale: Upscale the images with realesrgan-ncnn-vulkan (off by default)"
	printf '\t%s\n' "--framerate: Framerate of the final image in frames per second (default: '10')"
	printf '\t%s\n' "-r, --realesrgan-flags: Flags that are passed to realesrgan-ncnn-vulkan (no default)"
	printf '\t%s\n' "-f, --ffmpeg-flags: Flags that are passed to ffmpeg. Used to define the encoding pipeline. (default: '-c:v libx264 -crf 18 -preset veryslow -pix_fmt yuv420p')"
	printf '\t%s\n' "--verbose: Set verbose output (can be specified multiple times to increase the effect)"
	printf '\t%s\n' "-h, --help: Prints help"
	printf '\t%s\n' "-v, --version: Prints version"
	printf '%s: %s (define manually using %s)\n' "ffmpeg" "" "FFMPEG"
	printf '%s: %s (define manually using %s)\n' "convert" "" "IMAGEMAGICK_CONVERT"
	printf '%s: %s (define manually using %s)\n' "identify" "" "IMAGEMAGICK_IDENTIFY"
	printf '%s: %s (define manually using %s)\n' "realesrgan-ncnn-vulkan" "" "REALESRGAN_NCNN_VULKAN"
	printf '%s: %s (define manually using %s)\n' "mktemp" "" "MKTEMP"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-m|--imagemagick-options)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_imagemagick_options="$2"
				shift
				;;
			--imagemagick-options=*)
				_arg_imagemagick_options="${_key##--imagemagick-options=}"
				;;
			-m*)
				_arg_imagemagick_options="${_key##-m}"
				;;
			--aspect-ratio)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_aspect_ratio="$2"
				shift
				;;
			--aspect-ratio=*)
				_arg_aspect_ratio="${_key##--aspect-ratio=}"
				;;
			--cut-left)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_cut_left="$2"
				shift
				;;
			--cut-left=*)
				_arg_cut_left="${_key##--cut-left=}"
				;;
			--cut-right)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_cut_right="$2"
				shift
				;;
			--cut-right=*)
				_arg_cut_right="${_key##--cut-right=}"
				;;
			--cut-top)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_cut_top="$2"
				shift
				;;
			--cut-top=*)
				_arg_cut_top="${_key##--cut-top=}"
				;;
			--cut-bottom)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_cut_bottom="$2"
				shift
				;;
			--cut-bottom=*)
				_arg_cut_bottom="${_key##--cut-bottom=}"
				;;
			--cut-all)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_cut_all="$2"
				shift
				;;
			--cut-all=*)
				_arg_cut_all="${_key##--cut-all=}"
				;;
			--rotate)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_rotate="$2"
				shift
				;;
			--rotate=*)
				_arg_rotate="${_key##--rotate=}"
				;;
			-p|--parallelism)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_parallelism="$2"
				shift
				;;
			--parallelism=*)
				_arg_parallelism="${_key##--parallelism=}"
				;;
			-p*)
				_arg_parallelism="${_key##-p}"
				;;
			-o|--output)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_output="$2"
				shift
				;;
			--output=*)
				_arg_output="${_key##--output=}"
				;;
			-o*)
				_arg_output="${_key##-o}"
				;;
			--final-resolution)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_final_resolution="$2"
				shift
				;;
			--final-resolution=*)
				_arg_final_resolution="${_key##--final-resolution=}"
				;;
			-u|--no-upscale|--upscale)
				_arg_upscale="on"
				test "${1:0:5}" = "--no-" && _arg_upscale="off"
				;;
			-u*)
				_arg_upscale="on"
				_next="${_key##-u}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-u" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			--framerate)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_framerate="$2"
				shift
				;;
			--framerate=*)
				_arg_framerate="${_key##--framerate=}"
				;;
			-r|--realesrgan-flags)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_realesrgan_flags="$2"
				shift
				;;
			--realesrgan-flags=*)
				_arg_realesrgan_flags="${_key##--realesrgan-flags=}"
				;;
			-r*)
				_arg_realesrgan_flags="${_key##-r}"
				;;
			-f|--ffmpeg-flags)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_ffmpeg_flags="$2"
				shift
				;;
			--ffmpeg-flags=*)
				_arg_ffmpeg_flags="${_key##--ffmpeg-flags=}"
				;;
			-f*)
				_arg_ffmpeg_flags="${_key##-f}"
				;;
			--verbose)
				_arg_verbose=$((_arg_verbose + 1))
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			-v|--version)
				echo $0 v0.1.0
				exit 0
				;;
			-v*)
				echo $0 v0.1.0
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'frames'"
	test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_frames "
	_our_args=$((${#_positionals[@]} - 1))
	for ((ii = 0; ii < _our_args; ii++))
	do
		_positional_names="$_positional_names _arg_frames[$((ii + 1))]"
	done

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

check_prog()
{
	local _msg="$3"
	test -n "$_msg" || _msg="Unable to find a reachable executable '$2'"
	eval "test -n \"\$$1\" || $1=\"$2\""
	eval "command -v \"\$$1\" > /dev/null 2> /dev/null" || die "$_msg" 1
}

# Make sure that 'ffmpeg', 'convert', 'identify', 'realesrgan-ncnn-vulkan' and 'mktemp' are assigned to respective env vars.
check_prog "FFMPEG" 'ffmpeg'
check_prog "IMAGEMAGICK_CONVERT" 'convert'
check_prog "IMAGEMAGICK_IDENTIFY" 'identify'
check_prog "REALESRGAN_NCNN_VULKAN" 'realesrgan-ncnn-vulkan'
check_prog "MKTEMP" 'mktemp'
# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


# vvv  PLACE YOUR CODE HERE  vvv

N=4

if test "$_arg_parallelism" = "auto"; then
    N=$(nproc)
else
    N=$_arg_parallelism
fi

number_of_frames=${#_arg_frames[@]}

function progress_string {
    local progress=$1
    local total=$2
    local width=20
    local progress_chars=$(echo "scale=2; $progress / $total * $width" | bc)
    local progress_chars=${progress_chars%.*}
    local progress_string=$(printf "%${progress_chars}s" | tr ' ' '#')
    local remaining_chars=$((width - progress_chars))
    local remaining_string=$(printf "%${remaining_chars}s" | tr ' ' ' ')
    echo "[$progress_string$remaining_string] $progress / $total"
}

dimensions=""
failed=false
error=""

function verifyFrame {
    index=$1
    file="${_arg_frames[$index]}"

    if [ ! -f "$file" ]; then
        echo "Frame $file does not exist"
        exit 1
    fi

    file_dimensions=$($IMAGEMAGICK_IDENTIFY -format "%wx%h" "$file")

    if [ $? -ne 0 ]; then
        echo "Frame $file is not a valid image"
        exit 1
    fi

    if [ -z "$dimensions" ]; then
        dimensions="$file_dimensions"
    fi

    if [ "$dimensions" != "$file_dimensions" ]; then
        echo "Frame $file has different dimensions than the other frames.\nExpected $dimensions, got $file_dimensions"
        exit 1
    fi
}

# Verify frames
echo "Verifying frames"
declare -a pids=()

for index in "${!_arg_frames[@]}"; do
    echo "Verifying frames $(progress_string $((index + 1)) $number_of_frames)"
    if test $index -eq 0; then
        verifyFrame $index
        continue
    fi

    verifyFrame $index &
    pids+=($!)

    if (((index + 1) % N == 0 || index + 1 == number_of_frames)); then
        for pid in "${pids[@]}"; do
            if ! wait $pid; then
                exit 1
            fi
        done
        pids=()
    fi
done

WORKING_DIR=$(mktemp -d)

if test $_arg_verbose -ge 1; then
    echo "Working dir is $WORKING_DIR"
fi

natural_width=$(echo $dimensions | cut -d'x' -f1)
natural_height=$(echo $dimensions | cut -d'x' -f2)

cut_left=$((_arg_cut_left + _arg_cut_all))
cut_right=$((_arg_cut_right + _arg_cut_all))
cut_top=$((_arg_cut_top + _arg_cut_all))
cut_bottom=$((_arg_cut_bottom + _arg_cut_all))

cropped_width=$((natural_width - cut_left - cut_right))
cropped_height=$((natural_height - cut_top - cut_bottom))
cropped_offset_x=$cut_left
cropped_offset_y=$cut_top

crop_string="${cropped_width}x${cropped_height}+${cropped_offset_x}+${cropped_offset_y}"

natural_aspect_ratio="${cropped_width}:${cropped_height}"
final_aspect_ratio=$(echo $dimensions | sed 's/x/:/g')
aspect_ratio=${_final_aspect_ratio:-$natural_aspect_ratio}

# Imagemagick convert frames to png
mkdir -p "$WORKING_DIR/processed"
declare -a processed_frames=()

function fail {
    echo $@
    exit 1
}

function preprocess_file {
    file=$1
    converted_filename=$2

    $IMAGEMAGICK_CONVERT $file -distort SRT $_arg_rotate $converted_filename.alpha.png || fail "Failed to convert $file"
    $IMAGEMAGICK_CONVERT $converted_filename.alpha.png -crop $crop_string +repage $converted_filename.beta.png || fail "Failed to convert $file"
    $IMAGEMAGICK_CONVERT $converted_filename.beta.png -gravity center -crop $aspect_ratio +repage $converted_filename.gamma.png || fail "Failed to convert $file"
    sh -c "$IMAGEMAGICK_CONVERT $converted_filename.gamma.png $_arg_imagemagick_options +repage $converted_filename" || fail "Failed to convert $file"
    rm $converted_filename.alpha.png $converted_filename.beta.png $converted_filename.gamma.png

}

echo "Preprocessing frames with imagemagick"
pids=()
for index in "${!_arg_frames[@]}"; do
    file="${_arg_frames[$index]}"
    echo "Preprocessing frames with imagemagick $(progress_string $((index + 1)) $number_of_frames)"
    file_basename=$(basename $file)
    converted_filename="$WORKING_DIR/processed/${file_basename%.*}.png"
    preprocess_file $file $converted_filename &
    pids+=($!)
    processed_frames+=("$converted_filename")

    if (((index + 1) % N == 0 || index + 1 == number_of_frames)); then
        for pid in "${pids[@]}"; do
            if ! wait $pid; then
                exit 1
            fi
        done
        pids=()
    fi
done

# Upscale frames using realesrgan-ncnn-vulkan
mkdir -p "$WORKING_DIR/upscaled"
declare -a upscaled_frames=()

function parse_output {
    elapsed=$1
    last=""
    while read -r line; do
        grepped_line=$(echo $line | grep -Po '^[0-9]?[0-9]\.[0-9][0-9]%$' | grep -Po '^[0-9]?[0-9]')
        if [ -z "$grepped_line" ]; then
            continue
        fi
        if [ "$grepped_line" == "$last" ]; then
            continue
        fi
        last=$grepped_line

        value=$((elapsed * 100 + grepped_line))
        total=$((number_of_frames * 100))

        echo "Upscaling frames $(progress_string $value $total)%"
    done
}

echo "Preparing to upscale first frame"
for index in "${!processed_frames[@]}"; do
    file="${processed_frames[$index]}"
    file_basename=$(basename $file)
    upscaled_filename="$WORKING_DIR/upscaled/${file_basename%.*}.png"

    if [ $_arg_upscale = "on" ]; then
        sh -c "$REALESRGAN_NCNN_VULKAN -i $file -o $upscaled_filename $_arg_realesrgan_flags" |& parse_output $index

        if [ $? -ne 0 ]; then
            echo "Failed to upscale $file"
            exit 1
        fi

        value=$((index * 100 + 100))
        total=$((number_of_frames * 100))
        echo "Upscaling frames $(progress_string $value $total)%"
    else
        echo "AI upscaling is disabled. Use --upscale to enable"

        # $IMAGEMAGICK_CONVERT $file -resize 400% $upscaled_filename
        cp $file $upscaled_filename
        echo "NOT upscaling frames $(progress_string $((index + 1)) $number_of_frames)"
    fi
    upscaled_frames+=("$upscaled_filename")
done

declare -a final_frames=()
pids=()

if [ -n "$_arg_final_resolution" ]; then
    function scale_to_final_resolution {
        file=$1
        final_filename=$2
        $IMAGEMAGICK_CONVERT $file -geometry ${_arg_final_resolution}\! $final_filename || fail "Failed to scale $file"
    }

    mkdir -p "$WORKING_DIR/final"
    echo "Scaling frames to final height"
    for index in "${!upscaled_frames[@]}"; do
        file="${upscaled_frames[$index]}"
        file_basename=$(basename $file)
        final_filename="$WORKING_DIR/final/${file_basename%.*}.png"
        echo "Scaling frames to final height $(progress_string $((index + 1)) $number_of_frames)"

        scale_to_final_resolution $file $final_filename &
        pids+=($!)
        final_frames+=("$final_filename")

        if (((index + 1) % N == 0 || index + 1 == number_of_frames)); then
            for pid in "${pids[@]}"; do
                if ! wait $pid; then
                    exit 1
                fi
            done
            pids=()
        fi
    done
else
    final_frames=("${upscaled_frames[@]}")
fi

# Create timelapse with ffmpeg
echo "Creating file with all frames. All frames: ${#final_frames[@]}"
FRAMES_FILE="$WORKING_DIR/frames.txt"
rm -rf "$FRAMES_FILE"
for index in "${!final_frames[@]}"; do
    file="${final_frames[$index]}"
    echo "file '$file'" >>"$FRAMES_FILE"
done

set -x
sh -c "$FFMPEG -f concat -safe 0 -i $FRAMES_FILE -y -hide_banner -loglevel error -stats -r $_arg_framerate -vf \"settb=AVTB,setpts=N/$_arg_framerate/TB,fps=$_arg_framerate\" $_arg_ffmpeg_flags $_arg_output"

# realesrgan-ncnn-vulkan -i GOPR0066.JPG -o scaled/GOPR0066-net.JPG -n realesrnet-x4plus

# ^^^  TERMINATE YOUR CODE BEFORE THE BOTTOM ARGBASH MARKER  ^^^

# ] <-- needed because of Argbash
